<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <link rel=stylesheet  href="/css/weave.css"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <title>The Different Flavors of Parallelism - MIT Parallel Computing and Scientific Machine Learning (SciML)</title> <div id=layout > <div id=menu > <ul> <li><a style="font-size:larger;" href=https://github.com/SciML/SciMLBook><i class="fa fa-github"></i></a> <li><a style="font-size:larger;" href="/">Home</a> <li><a style="font-size:larger;" href="/course/">Course</a> <li><a style="font-size:larger;" href="/homework/">Homework</a> <li><a style="font-size:larger;" href="/lectures/">Lectures</a> <li><a style="font-size:larger;" href="/notes/">Notes</a> <ul style="font-size:smaller"> <li><a href="/notes/02-Optimizing_Serial_Code/">02: Serial Code</a> <li><a href="/notes/03-Introduction_to_Scientific_Machine_Learning_through_Physics-Informed_Neural_Networks/">03: SciML Intro</a> <li><a href="/notes/04-How_Loops_Work-An_Introduction_to_Discrete_Dynamics/">04: How Loops Work</a> <li><a href="/notes/05-The_Basics_of_Single_Node_Parallel_Computing/">05: Basics of Parallelism</a> <li><a href="/notes/06-The_Different_Flavors_of_Parallelism/">06: Flavors of Parallelism</a> <li><a href="/notes/07-Ordinary_Differential_Equations-Applications_and_Discretizations/">07: ODEs</a> <li><a href="/notes/08-Forward-Mode_Automatic_Differentiation_(AD)_via_High_Dimensional_Algebras/">08: Forward AD</a> <li><a href="/notes/09-Solving_Stiff_Ordinary_Differential_Equations/">09: Stiff ODEs</a> <li><a href="/notes/10-Basic_Parameter_Estimation-Reverse-Mode_AD-and_Inverse_Problems/">10: Reverse AD</a> <li><a href="/notes/11-Differentiable_Programming_and_Neural_Differential_Equations/">11: δP</a> <li><a href="/notes/12-Description_of_MPI_and_MPI/">12: MPI</a> <li><a href="/notes/13-GPU_programming/">13: GPUs</a> <li><a href="/notes/14-PDEs_Convolutions_and_the_Mathematics_of_Locality/">14: PDEs</a> <li><a href="/notes/15-Mixing_Differential_Equations_and_Neural_Networks_for_Physics-Informed_Learning/">15: Physics Informed Learning</a> <li><a href="/notes/16-From_Optimization_to_Probabilistic_Programming/">16: Probabilistic Programming</a> <li><a href="/notes/17-Global_Sensitivity_Analysis/">17: Global Sensitivity Analysis</a> <li><a href="/notes/18-Code_Profiling_and_Optimization/">18: Profiling & Optimization</a> <li><a href="/notes/19-Uncertainty_Programming-Generalized_Uncertainty_Quantification/">19: Uncertainty Programming</a> </ul> </ul> </div> <div id=main > <div class=franklin-content > <h1 class=title >The Different Flavors of Parallelism</h1> <h5>Chris Rackauckas</h5> <h5>September 25th, 2020</h5> <h2><a href="https://youtu.be/EP5VWwPIews">Youtube Video Link</a></h2> <p>Now that you are aware of the basics of parallel computing, let&#39;s give a high level overview of the differences between different modes of parallelism.</p> <h2>Lowest Level: SIMD</h2> <p>Recall SIMD, the idea that processors can run multiple commands simultaneously on specially structured data. &quot;Single Instruction Multiple Data&quot;. SIMD is parallelism within a single core.</p> <h3>High Level Idea of SIMD</h3> <p>Calculations can occur in parallel in the processor if there is sufficient structure in the computation.</p> <h3>How to do SIMD</h3> <p>The simplest way to do SIMD is simply to make sure that your values are aligned. If they are, then great, LLVM&#39;s autovectorizer pass has a good chance of automatic vectorization &#40;in the world of computing, &quot;SIMD&quot; is synonymous with vectorization since it is taking specific values and instead computing on small vectors. That is not to be confused with &quot;vectorization&quot; in the sense of Python/R/MATLAB, which is a programming style which prefers using C-defined primitive functions, like broadcast or matrix multiplication&#41;.</p> <p>You can check for auto-vectorization inside of the LLVM IR by looking for statements like:</p> <pre><code>&#37;wide.load24 &#61; load &lt;4 x double&gt;, &lt;4 x double&gt; addrspac&#40;13&#41;* &#37;46, align 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
&#37;47 &#61; fadd &lt;4 x double&gt; &#37;wide.load, &#37;wide.load24</code></pre> <p>which means that 4 additions are happening simultaneously. The amount of vectorization is heavily dependent on your architecture. The ancient form of SIMD, the SSE&#40;2&#41; instructions, required that your data was aligned. Now there&#39;s a bit more leeway, but generally it holds that making your the data you&#39;re trying to SIMD over is aligned. Thus there can be major differences in computing using a <em>struct of array</em> format instead of an <em>arrays of structs</em> format. For example:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MyComplex</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>arr</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(),</span><span class='hljl-nf'>rand</span><span class='hljl-p'>())</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
100-element Vector&#123;MyComplex&#125;:
 MyComplex&#40;0.22877358229861378, 0.5658237391465198&#41;
 MyComplex&#40;0.828784302016415, 0.6877754329893743&#41;
 MyComplex&#40;0.4154864818254249, 0.5344533379826805&#41;
 MyComplex&#40;0.6429900762018897, 0.09790121601102764&#41;
 MyComplex&#40;0.554992156756729, 0.10517032798324111&#41;
 MyComplex&#40;0.5785359794084292, 0.9434907285102846&#41;
 MyComplex&#40;0.43884386499543593, 0.2815604441165559&#41;
 MyComplex&#40;0.5051917926836756, 0.9470125131694147&#41;
 MyComplex&#40;0.14887867852687253, 0.6964967145794316&#41;
 MyComplex&#40;0.647782357181149, 0.5979921895154651&#41;
 ⋮
 MyComplex&#40;0.34088303613571935, 0.01980794968901911&#41;
 MyComplex&#40;0.24240892563451444, 0.31016895660546007&#41;
 MyComplex&#40;0.13613632756439897, 0.6599149850729149&#41;
 MyComplex&#40;0.40306042055911084, 0.42666978763770536&#41;
 MyComplex&#40;0.10404951417499708, 0.7269283566416433&#41;
 MyComplex&#40;0.11916782602847542, 0.6141123373193637&#41;
 MyComplex&#40;0.3159150470396115, 0.08174910869715746&#41;
 MyComplex&#40;0.56233698991025, 0.7386142926699587&#41;
 MyComplex&#40;0.13293887458355513, 0.333377609529079&#41;
</pre> <p>is represented in memory as</p> <pre><code>&#91;real1,imag1,real2,imag2,...&#93;</code></pre>
<p>while the struct of array formats are</p>


<pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MyComplexes</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Vector</span><span class='hljl-p'>{</span><span class='hljl-n'>Float64</span><span class='hljl-p'>}</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Vector</span><span class='hljl-p'>{</span><span class='hljl-n'>Float64</span><span class='hljl-p'>}</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>arr2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplexes</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>),</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>))</span>
</pre>


<pre class=output >
MyComplexes&#40;&#91;0.011092251358889249, 0.42683584822941034, 0.24407435269468447
, 0.2099729124762253, 0.4150494330774952, 0.3715087513254718, 0.22512986421
43139, 0.7138373664982224, 0.8339552735694008, 0.5406548312379378  …  0.760
2515411810592, 0.5727958697076371, 0.6868979509203106, 0.20833850646677465,
 0.6367078383693908, 0.1524533884439465, 0.7147218068338909, 0.218933135030
2669, 0.5854165952668722, 0.17877347612543293&#93;, &#91;0.361203135179446, 0.52059
90901482361, 0.5655408702878107, 0.48720795470976896, 0.4858185802190793, 0
.9346769240240785, 0.7381745597939556, 0.9476227903343227, 0.59583110838678
95, 0.8346921408793201  …  0.9481755440125621, 0.21742767201007096, 0.86420
39428280606, 0.2814460982100566, 0.6192003530089029, 0.047680949002491646, 
0.5027680457609128, 0.6878413674489543, 0.7435739634778878, 0.0862173300258
4497&#93;&#41;
</pre>


<p>Now let&#39;s check what happens when we perform a reduction:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>InteractiveUtils</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:/</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>/</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>/</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>average</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Vector</span><span class='hljl-p'>{</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>})</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-oB'>/</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>average</span><span class='hljl-p'>(</span><span class='hljl-n'>arr</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
; Function Signature: average&#40;Array&#123;Main.MyComplex, 1&#125;&#41;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:5 within &#96;average&#96;
define void @julia_average_70476&#40;ptr noalias nocapture noundef nonnull sret
&#40;&#91;2 x double&#93;&#41; align 8 dereferenceable&#40;16&#41; &#37;sret_return, ptr noundef nonnul
l align 8 dereferenceable&#40;24&#41; &#37;&quot;x::Array&quot;&#41; #0 &#123;
top:
  &#37;jlcallframe1 &#61; alloca &#91;4 x ptr&#93;, align 8
  &#37;0 &#61; alloca &#91;2 x double&#93;, align 16
; ┌ @ reducedim.jl:982 within &#96;sum&#96;
; │┌ @ reducedim.jl:982 within &#96;#sum#933&#96;
; ││┌ @ reducedim.jl:986 within &#96;_sum&#96;
; │││┌ @ reducedim.jl:986 within &#96;#_sum#935&#96;
; ││││┌ @ reducedim.jl:987 within &#96;_sum&#96;
; │││││┌ @ reducedim.jl:987 within &#96;#_sum#936&#96;
; ││││││┌ @ reducedim.jl:329 within &#96;mapreduce&#96;
; │││││││┌ @ reducedim.jl:329 within &#96;#mapreduce#926&#96;
; ││││││││┌ @ reducedim.jl:337 within &#96;_mapreduce_dim&#96;
; │││││││││┌ @ reduce.jl:426 within &#96;_mapreduce&#96;
; ││││││││││┌ @ indices.jl:494 within &#96;LinearIndices&#96;
; │││││││││││┌ @ abstractarray.jl:98 within &#96;axes&#96;
; ││││││││││││┌ @ array.jl:194 within &#96;size&#96;
               &#37;1 &#61; getelementptr inbounds i8, ptr &#37;&quot;x::Array&quot;, i64 16
               &#37;.size.sroa.0.0.copyload &#61; load i64, ptr &#37;1, align 8
; ││││││││││└└└
; ││││││││││ @ reduce.jl:428 within &#96;_mapreduce&#96;
            switch i64 &#37;.size.sroa.0.0.copyload, label &#37;L31 &#91;
    i64 0, label &#37;L8
    i64 1, label &#37;guard_pass99
  &#93;

L8:                                               ; preds &#61; &#37;top
; ││││││││││ @ reduce.jl:429 within &#96;_mapreduce&#96;
            store ptr @&quot;jl_global#70486.jit&quot;, ptr &#37;jlcallframe1, align 8
            &#37;2 &#61; getelementptr inbounds ptr, ptr &#37;jlcallframe1, i64 1
            store ptr @&quot;jl_global#70487.jit&quot;, ptr &#37;2, align 8
            &#37;3 &#61; getelementptr inbounds ptr, ptr &#37;jlcallframe1, i64 2
            store ptr &#37;&quot;x::Array&quot;, ptr &#37;3, align 8
            &#37;4 &#61; getelementptr inbounds ptr, ptr &#37;jlcallframe1, i64 3
            store ptr @&quot;jl_global#70488.jit&quot;, ptr &#37;4, align 8
            &#37;5 &#61; call nonnull ptr @ijl_invoke&#40;ptr nonnull @&quot;jl_global#70485
.jit&quot;, ptr nonnull &#37;jlcallframe1, i32 4, ptr nonnull @&quot;-Main.Base.mapreduce
_empty_iter#70484.jit&quot;&#41;
            call void @llvm.trap&#40;&#41;
            unreachable

L31:                                              ; preds &#61; &#37;top
; ││││││││││ @ reduce.jl:433 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:83 within &#96;&lt;&#96;
             &#37;6 &#61; icmp sgt i64 &#37;.size.sroa.0.0.copyload, 15
; ││││││││││└
            br i1 &#37;6, label &#37;guard_pass109, label &#37;guard_exit115

L110.loopexit.unr-lcssa:                          ; preds &#61; &#37;guard_exit120,
 &#37;guard_exit120.preheader
            &#37;.lcssa.ph &#61; phi &lt;2 x double&gt; &#91; undef, &#37;guard_exit120.preheader
 &#93;, &#91; &#37;60, &#37;guard_exit120 &#93;
            &#37;value_phi61145.unr &#61; phi i64 &#91; 2, &#37;guard_exit120.preheader &#93;, 
&#91; &#37;57, &#37;guard_exit120 &#93;
            &#37;.unr &#61; phi &lt;2 x double&gt; &#91; &#37;24, &#37;guard_exit120.preheader &#93;, &#91; &#37;
60, &#37;guard_exit120 &#93;
; ││││││││││ @ reduce.jl:438 within &#96;_mapreduce&#96;
            &#37;lcmp.mod.not &#61; icmp eq i64 &#37;xtraiter, 0
            br i1 &#37;lcmp.mod.not, label &#37;L110, label &#37;guard_exit120.epil

guard_exit120.epil:                               ; preds &#61; &#37;guard_exit120.
epil, &#37;L110.loopexit.unr-lcssa
            &#37;value_phi61145.epil &#61; phi i64 &#91; &#37;8, &#37;guard_exit120.epil &#93;, &#91; &#37;
value_phi61145.unr, &#37;L110.loopexit.unr-lcssa &#93;
            &#37;7 &#61; phi &lt;2 x double&gt; &#91; &#37;11, &#37;guard_exit120.epil &#93;, &#91; &#37;.unr, &#37;L
110.loopexit.unr-lcssa &#93;
            &#37;epil.iter &#61; phi i64 &#91; &#37;epil.iter.next, &#37;guard_exit120.epil &#93;, 
&#91; 0, &#37;L110.loopexit.unr-lcssa &#93;
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;8 &#61; add nuw nsw i64 &#37;value_phi61145.epil, 1
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;9 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;value_
phi61145.epil
             &#37;10 &#61; load &lt;2 x double&gt;, ptr &#37;9, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;11 &#61; fadd &lt;2 x double&gt; &#37;7, &#37;10
; ││││││││││└└
; ││││││││││ @ reduce.jl:438 within &#96;_mapreduce&#96;
            &#37;epil.iter.next &#61; add i64 &#37;epil.iter, 1
            &#37;epil.iter.cmp.not &#61; icmp eq i64 &#37;epil.iter.next, &#37;xtraiter
            br i1 &#37;epil.iter.cmp.not, label &#37;L110, label &#37;guard_exit120.epi
l

L110:                                             ; preds &#61; &#37;guard_exit115,
 &#37;guard_pass109, &#37;guard_pass99, &#37;guard_exit120.epil, &#37;L110.loopexit.unr-lcs
sa
; └└└└└└└└└└
; ┌ @ essentials.jl:11 within &#96;length&#96;
   &#37;.size12.sroa.0.0.copyload &#61; phi i64 &#91; &#37;.size12.sroa.0.0.copyload.pre, &#37;
guard_pass109 &#93;, &#91; 1, &#37;guard_pass99 &#93;, &#91; &#37;.size.sroa.0.0.copyload, &#37;guard_e
xit115 &#93;, &#91; &#37;.size.sroa.0.0.copyload, &#37;guard_exit120.epil &#93;, &#91; &#37;.size.sroa.
0.0.copyload, &#37;L110.loopexit.unr-lcssa &#93;
   &#37;12 &#61; phi &lt;2 x double&gt; &#91; &#37;19, &#37;guard_pass109 &#93;, &#91; &#37;18, &#37;guard_pass99 &#93;, 
&#91; &#37;24, &#37;guard_exit115 &#93;, &#91; &#37;.lcssa.ph, &#37;L110.loopexit.unr-lcssa &#93;, &#91; &#37;11, &#37;
guard_exit120.epil &#93;
; └
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_para
llelism.jmd:4 within &#96;/&#96; @ promotion.jl:432
; │┌ @ promotion.jl:400 within &#96;promote&#96;
; ││┌ @ promotion.jl:375 within &#96;_promote&#96;
; │││┌ @ number.jl:7 within &#96;convert&#96;
; ││││┌ @ float.jl:239 within &#96;Float64&#96;
       &#37;13 &#61; sitofp i64 &#37;.size12.sroa.0.0.copyload to double
; │└└└└
; │ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_para
llelism.jmd:4 within &#96;/&#96; @ promotion.jl:432 @ float.jl:494
   &#37;14 &#61; insertelement &lt;2 x double&gt; poison, double &#37;13, i64 0
   &#37;15 &#61; shufflevector &lt;2 x double&gt; &#37;14, &lt;2 x double&gt; poison, &lt;2 x i32&gt; zer
oinitializer
   &#37;16 &#61; fdiv &lt;2 x double&gt; &#37;12, &#37;15
; │ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_para
llelism.jmd:4 within &#96;/&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_par
allelism.jmd:3 within &#96;MyComplex&#96;
    store &lt;2 x double&gt; &#37;16, ptr &#37;sret_return, align 8
    ret void

guard_pass99:                                     ; preds &#61; &#37;top
; └└
; ┌ @ reducedim.jl:982 within &#96;sum&#96;
; │┌ @ reducedim.jl:982 within &#96;#sum#933&#96;
; ││┌ @ reducedim.jl:986 within &#96;_sum&#96;
; │││┌ @ reducedim.jl:986 within &#96;#_sum#935&#96;
; ││││┌ @ reducedim.jl:987 within &#96;_sum&#96;
; │││││┌ @ reducedim.jl:987 within &#96;#_sum#936&#96;
; ││││││┌ @ reducedim.jl:329 within &#96;mapreduce&#96;
; │││││││┌ @ reducedim.jl:329 within &#96;#mapreduce#926&#96;
; ││││││││┌ @ reducedim.jl:337 within &#96;_mapreduce_dim&#96;
; │││││││││┌ @ reduce.jl:431 within &#96;_mapreduce&#96;
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;17 &#61; load ptr, ptr &#37;&quot;x::Array&quot;, align 8
             &#37;18 &#61; load &lt;2 x double&gt;, ptr &#37;17, align 8
             br label &#37;L110

guard_pass109:                                    ; preds &#61; &#37;L31
; ││││││││││└
; ││││││││││ @ reduce.jl:444 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:277 within &#96;mapreduce_impl&#96;
             call void @j_mapreduce_impl_70505&#40;ptr noalias nocapture nounde
f nonnull sret&#40;&#91;2 x double&#93;&#41; &#37;0, ptr nonnull &#37;&quot;x::Array&quot;, i64 signext 1, i6
4 signext &#37;.size.sroa.0.0.copyload, i64 signext 1024&#41;
; └└└└└└└└└└└
  &#37;19 &#61; load &lt;2 x double&gt;, ptr &#37;0, align 16
; ┌ @ essentials.jl:11 within &#96;length&#96;
   &#37;.size12.sroa.0.0.copyload.pre &#61; load i64, ptr &#37;1, align 8
   br label &#37;L110

guard_exit115:                                    ; preds &#61; &#37;L31
; └
; ┌ @ reducedim.jl:982 within &#96;sum&#96;
; │┌ @ reducedim.jl:982 within &#96;#sum#933&#96;
; ││┌ @ reducedim.jl:986 within &#96;_sum&#96;
; │││┌ @ reducedim.jl:986 within &#96;#_sum#935&#96;
; ││││┌ @ reducedim.jl:987 within &#96;_sum&#96;
; │││││┌ @ reducedim.jl:987 within &#96;#_sum#936&#96;
; ││││││┌ @ reducedim.jl:329 within &#96;mapreduce&#96;
; │││││││┌ @ reducedim.jl:329 within &#96;#mapreduce#926&#96;
; ││││││││┌ @ reducedim.jl:337 within &#96;_mapreduce_dim&#96;
; │││││││││┌ @ reduce.jl:435 within &#96;_mapreduce&#96;
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;20 &#61; load ptr, ptr &#37;&quot;x::Array&quot;, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:436 within &#96;_mapreduce&#96;
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;21 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 1
; ││││││││││└
; ││││││││││ @ reduce.jl:435 within &#96;_mapreduce&#96;
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;22 &#61; load &lt;2 x double&gt;, ptr &#37;20, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:436 within &#96;_mapreduce&#96;
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;23 &#61; load &lt;2 x double&gt;, ptr &#37;21, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:437 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;24 &#61; fadd &lt;2 x double&gt; &#37;22, &#37;23
; ││││││││││└└
; ││││││││││ @ reduce.jl:438 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:83 within &#96;&lt;&#96;
             &#37;.not141142 &#61; icmp sgt i64 &#37;.size.sroa.0.0.copyload, 2
; ││││││││││└
            br i1 &#37;.not141142, label &#37;guard_exit120.preheader, label &#37;L110

guard_exit120.preheader:                          ; preds &#61; &#37;guard_exit115
            &#37;25 &#61; add i64 &#37;.size.sroa.0.0.copyload, -2
            &#37;26 &#61; add i64 &#37;.size.sroa.0.0.copyload, -3
            &#37;xtraiter &#61; and i64 &#37;25, 7
            &#37;27 &#61; icmp ult i64 &#37;26, 7
            br i1 &#37;27, label &#37;L110.loopexit.unr-lcssa, label &#37;guard_exit120
.preheader.new

guard_exit120.preheader.new:                      ; preds &#61; &#37;guard_exit120.
preheader
            &#37;unroll_iter &#61; and i64 &#37;25, -8
            br label &#37;guard_exit120

guard_exit120:                                    ; preds &#61; &#37;guard_exit120,
 &#37;guard_exit120.preheader.new
            &#37;value_phi61145 &#61; phi i64 &#91; 2, &#37;guard_exit120.preheader.new &#93;, 
&#91; &#37;57, &#37;guard_exit120 &#93;
            &#37;28 &#61; phi &lt;2 x double&gt; &#91; &#37;24, &#37;guard_exit120.preheader.new &#93;, &#91;
 &#37;60, &#37;guard_exit120 &#93;
            &#37;niter &#61; phi i64 &#91; 0, &#37;guard_exit120.preheader.new &#93;, &#91; &#37;niter.
next.7, &#37;guard_exit120 &#93;
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;29 &#61; or i64 &#37;value_phi61145, 1
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;30 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;value
_phi61145
             &#37;31 &#61; load &lt;2 x double&gt;, ptr &#37;30, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;32 &#61; fadd &lt;2 x double&gt; &#37;28, &#37;31
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;33 &#61; add nuw nsw i64 &#37;value_phi61145, 2
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;34 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;29
             &#37;35 &#61; load &lt;2 x double&gt;, ptr &#37;34, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;36 &#61; fadd &lt;2 x double&gt; &#37;32, &#37;35
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;37 &#61; add nuw nsw i64 &#37;value_phi61145, 3
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;38 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;33
             &#37;39 &#61; load &lt;2 x double&gt;, ptr &#37;38, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;40 &#61; fadd &lt;2 x double&gt; &#37;36, &#37;39
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;41 &#61; add nuw nsw i64 &#37;value_phi61145, 4
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;42 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;37
             &#37;43 &#61; load &lt;2 x double&gt;, ptr &#37;42, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;44 &#61; fadd &lt;2 x double&gt; &#37;40, &#37;43
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;45 &#61; add nuw nsw i64 &#37;value_phi61145, 5
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;46 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;41
             &#37;47 &#61; load &lt;2 x double&gt;, ptr &#37;46, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;48 &#61; fadd &lt;2 x double&gt; &#37;44, &#37;47
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;49 &#61; add nuw nsw i64 &#37;value_phi61145, 6
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;50 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;45
             &#37;51 &#61; load &lt;2 x double&gt;, ptr &#37;50, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;52 &#61; fadd &lt;2 x double&gt; &#37;48, &#37;51
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;53 &#61; add nuw nsw i64 &#37;value_phi61145, 7
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;54 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;49
             &#37;55 &#61; load &lt;2 x double&gt;, ptr &#37;54, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;56 &#61; fadd &lt;2 x double&gt; &#37;52, &#37;55
; ││││││││││└└
; ││││││││││ @ reduce.jl:439 within &#96;_mapreduce&#96;
; ││││││││││┌ @ int.jl:87 within &#96;&#43;&#96;
             &#37;57 &#61; add nuw nsw i64 &#37;value_phi61145, 8
; ││││││││││└
; ││││││││││┌ @ essentials.jl:917 within &#96;getindex&#96;
             &#37;58 &#61; getelementptr inbounds &#91;2 x double&#93;, ptr &#37;20, i64 &#37;53
             &#37;59 &#61; load &lt;2 x double&gt;, ptr &#37;58, align 8
; ││││││││││└
; ││││││││││ @ reduce.jl:440 within &#96;_mapreduce&#96;
; ││││││││││┌ @ reduce.jl:24 within &#96;add_sum&#96;
; │││││││││││┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/sty
les_of_parallelism.jmd:3 within &#96;&#43;&#96; @ float.jl:491
              &#37;60 &#61; fadd &lt;2 x double&gt; &#37;56, &#37;59
; ││││││││││└└
; ││││││││││ @ reduce.jl:438 within &#96;_mapreduce&#96;
            &#37;niter.next.7 &#61; add i64 &#37;niter, 8
            &#37;niter.ncmp.7 &#61; icmp eq i64 &#37;niter.next.7, &#37;unroll_iter
            br i1 &#37;niter.ncmp.7, label &#37;L110.loopexit.unr-lcssa, label &#37;gua
rd_exit120
; └└└└└└└└└└
&#125;
</pre>


<p>What this is doing is creating small little vectors and then parallelizing the operations of those vectors by calling specific vector-parallel instructions. Keep this in mind.</p>
<h3>Explicit SIMD</h3>
<p>The following was all a form of <strong>loop-level parallelism</strong> known as loop vectorization. It&#39;s simply easier for compilers to reason at the array level, prove iterates are independent, and automatically generate SIMD code from that. This is not necessary, and compilers can produce SIMD code from non-looping code through a process known as <strong>SLP supervectorization</strong>, but the results are far from optimal and the compiler requires a lot of time to do this calculation, meaning that it&#39;s usually not a pass used by default.</p>
<p>If you want to pack the vectors yourself, then primitives for doing so from within Julia are available in SIMD.jl. This is for &quot;real&quot; performance warriors. This looks like for example:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>SIMD</span><span class='hljl-t'>
</span><span class='hljl-n'>v</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Vec</span><span class='hljl-p'>{</span><span class='hljl-ni'>4</span><span class='hljl-p'>,</span><span class='hljl-n'>Float64</span><span class='hljl-p'>}((</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>3</span><span class='hljl-p'>,</span><span class='hljl-ni'>4</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>v</span><span class='hljl-oB'>+</span><span class='hljl-n'>v</span><span class='hljl-t'> </span><span class='hljl-cs'># basic arithmetic is supported</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>v</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-cs'># basic reductions are supported</span>
</pre>


<pre class=output >
v &#43; v &#61; &lt;4 x Float64&gt;&#91;2.0, 4.0, 6.0, 8.0&#93;
sum&#40;v&#41; &#61; 10.0
10.0
</pre>


<p>Using this you can pull apart code and force the usage of SIMD vectors. One library which makes great use of this is LoopVectorization.jl. However, one word of &quot;caution&quot;:</p>
<p><strong>Most performance optimization is not trying to do something really good for performance. Most performance optimization is trying to not do something that is actively bad for performance.</strong></p>
<h3>Summary of SIMD</h3>
<ul>
<li><p>Communication in SIMD is due to locality: if things are local the processor can automatically setup the operations.</p>

<li><p>There&#39;s no real worry about &quot;getting it wrong&quot;: you cannot overwrite pieces from different parts of the arithmetic unit, and if SIMD is unsafe then it just won&#39;t auto-vectorize.</p>

<li><p>Suitable for operations measured in ns.</p>

</ul>
<h2>Next Level Up: Multithreading</h2>
<p>Last time we briefly went over multithreading and described how every process has multiple threads which share a single heap, and when multiple threads are executed simultaneously we have multithreaded parallelism. Note that you can have multiple threads which aren&#39;t executed simultaneously, like in the case of I/O operations, and this is an example of concurrency without parallelism and is commonly referred to as green threads.</p>
<p><img src="https://blog-assets.risingstack.com/2017/02/kernel-processes-and-threads-1.png" alt="" /></p>
<p>Last time we described a simple multithreaded program and noticed that multithreading has an overhead cost of around 50ns-100ns. This is due to the construction of the new stack &#40;among other things&#41; each time a new computational thread is spun up. This means that, unlike SIMD, some thought needs to be put in as to when to perform multithreading: it&#39;s not always a good idea. It needs to be high enough on the cost for this to be counter-balanced.</p>
<p>One abstraction that was glossed over was the memory access style. Before, we were considering a single heap, or an UMA style:</p>
<p><img src="https://software.intel.com/sites/default/files/m/2/0/4/e/d/39352-figure-1.jpg" alt="" /></p>
<p>However, this is the case for all shared memory devices. For example, compute nodes on the HPC tend to be &quot;dual Xeon&quot; or &quot;quad Xeon&quot;, where each Xeon processor is itself a multicore processor. But each processor on its own accesses its own local caches, and thus one has to be aware that this is setup in a NUMA &#40;non-uniform memory access&#41; manner:</p>
<p><img src="https://software.intel.com/sites/default/files/m/2/d/c/b/2/39353-figure-2.jpg" alt="" /></p>
<p>where there is a cache that is closer to the processor and a cache that is further away. Care should be taken in this to localize the computation per thread, otherwise a cost associated with the memory sharing will be hit &#40;but all sharing will still be automatic&#41;.</p>
<p>In this sense, interthread communication is naturally done through the heap: if you want other threads to be able to touch a value, then you can simply place it on the heap and then it&#39;ll be available. We saw this last time by how overlapping computations can re-use the same heap-based caches, meaning that care needs to be taken with how one writes into a dynamically-allocated array.</p>
<p>A simple example that demonstrates this is. First, let&#39;s make sure we have multithreading enabled:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Base</span><span class='hljl-oB'>.</span><span class='hljl-n'>Threads</span><span class='hljl-t'>
</span><span class='hljl-n'>Threads</span><span class='hljl-oB'>.</span><span class='hljl-nf'>nthreads</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-cs'># should not be 1</span>
</pre>


<pre class=output >
1
</pre>



<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-n'>acc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
</span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
    </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>acc</span><span class='hljl-t'>
    </span><span class='hljl-n'>acc</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>acc</span>
</pre>


<pre class=output >
10000
</pre>


<p>The reason for this behavior is that there is a difference between the reading and the writing step to an array. Here, values are being read while other threads are writing, meaning that they see a lower value than when they are attempting to write into it. The result is that the total summation is lower than the true value because of this clashing. We can prevent this by only allowing one thread to utilize the heap-allocated variable at a time. One abstraction for doing this is <em>atomics</em>:</p>


<pre class='hljl'>
<span class='hljl-n'>acc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Atomic</span><span class='hljl-p'>{</span><span class='hljl-n'>Int64</span><span class='hljl-p'>}(</span><span class='hljl-ni'>0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
    </span><span class='hljl-nf'>atomic_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>acc</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>acc</span>
</pre>


<pre class=output >
Atomic&#123;Int64&#125;&#40;10000&#41;
</pre>


<p>When an atomic add is being done, all other threads wishing to do the same computation are blocked. This of course can have a massive effect on performance since atomic computations are not parallel.</p>
<p>Julia also exposes a lower level of heap control in threading using <em>locks</em></p>


<pre class='hljl'>
<span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>acc_lock</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Ref</span><span class='hljl-p'>{</span><span class='hljl-n'>Int64</span><span class='hljl-p'>}(</span><span class='hljl-ni'>0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>splock</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>SpinLock</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>f1</span><span class='hljl-p'>()</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
        </span><span class='hljl-nf'>lock</span><span class='hljl-p'>(</span><span class='hljl-n'>splock</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-n'>acc_lock</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
        </span><span class='hljl-nf'>unlock</span><span class='hljl-p'>(</span><span class='hljl-n'>splock</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>rsplock</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>ReentrantLock</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>f2</span><span class='hljl-p'>()</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
        </span><span class='hljl-nf'>lock</span><span class='hljl-p'>(</span><span class='hljl-n'>rsplock</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-n'>acc_lock</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
        </span><span class='hljl-nf'>unlock</span><span class='hljl-p'>(</span><span class='hljl-n'>rsplock</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>acc2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Atomic</span><span class='hljl-p'>{</span><span class='hljl-n'>Int64</span><span class='hljl-p'>}(</span><span class='hljl-ni'>0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>()</span><span class='hljl-t'>
  </span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
      </span><span class='hljl-nf'>atomic_add!</span><span class='hljl-p'>(</span><span class='hljl-n'>acc2</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>acc_s</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Ref</span><span class='hljl-p'>{</span><span class='hljl-n'>Int64</span><span class='hljl-p'>}(</span><span class='hljl-ni'>0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>()</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>acc_s</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10_000</span><span class='hljl-t'>
      </span><span class='hljl-n'>acc_s</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>f1</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
50.343 μs &#40;7 allocations: 576 bytes&#41;
</pre>


<p><code>SpinLock</code> is non-reentrant, i.e. it will block itself if a thread that calls a <code>lock</code> does another <code>lock</code>. Therefore it has to be used with caution &#40;every <code>lock</code> goes with one <code>unlock</code>&#41;, but it&#39;s fast. <code>ReentrantLock</code> alleviates those concerns, but trades off a bit of performance:</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>f2</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
64.701 μs &#40;7 allocations: 576 bytes&#41;
</pre>


<p>But if you can use atomics, they will be faster:</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
19.807 μs &#40;7 allocations: 576 bytes&#41;
</pre>


<p>and if your computation is actually serial, then use serial code:</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
2.785 ns &#40;0 allocations: 0 bytes&#41;
</pre>


<p>Why is this so fast? Check the code:</p>


<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
; Function Signature: h&#40;&#41;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:26 within &#96;h&#96;
define void @julia_h_71785&#40;&#41; #0 &#123;
top:
  &#37;&quot;jl_global#71789.jit.promoted&quot; &#61; load i64, ptr @&quot;jl_global#71789.jit&quot;, a
lign 256
  &#37;0 &#61; add i64 &#37;&quot;jl_global#71789.jit.promoted&quot;, 10000
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:29 within &#96;h&#96;
  store i64 &#37;0, ptr @&quot;jl_global#71789.jit&quot;, align 256
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:30 within &#96;h&#96;
  ret void
&#125;
</pre>


<p>It just knows to add 10000. So to get a proper timing let&#39;s make the size mutable:</p>


<pre class='hljl'>
<span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>len</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Ref</span><span class='hljl-p'>{</span><span class='hljl-n'>Int</span><span class='hljl-p'>}(</span><span class='hljl-ni'>10_000</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>h2</span><span class='hljl-p'>()</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>acc_s</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>len</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-n'>len</span><span class='hljl-p'>[]</span><span class='hljl-t'>
      </span><span class='hljl-n'>acc_s</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>h2</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
2.785 ns &#40;0 allocations: 0 bytes&#41;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>h2</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
; Function Signature: h2&#40;&#41;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:3 within &#96;h2&#96;
define void @julia_h2_71833&#40;&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:6 within &#96;h2&#96;
; ┌ @ refvalue.jl:59 within &#96;getindex&#96;
; │┌ @ Base.jl:49 within &#96;getproperty&#96;
    &#37;.x &#61; load i64, ptr @&quot;jl_global#71837.jit&quot;, align 16
; └└
; ┌ @ range.jl:904 within &#96;iterate&#96;
; │┌ @ range.jl:681 within &#96;isempty&#96;
; ││┌ @ operators.jl:379 within &#96;&gt;&#96;
; │││┌ @ int.jl:83 within &#96;&lt;&#96;
      &#37;0 &#61; icmp slt i64 &#37;.x, 1
; └└└└
  br i1 &#37;0, label &#37;L34, label &#37;L18.preheader

L18.preheader:                                    ; preds &#61; &#37;top
  &#37;&quot;jl_global#71842.jit.promoted&quot; &#61; load i64, ptr @&quot;jl_global#71842.jit&quot;, a
lign 256
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:8 within &#96;h2&#96;
  &#37;1 &#61; add i64 &#37;&quot;jl_global#71842.jit.promoted&quot;, &#37;.x
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:7 within &#96;h2&#96;
  store i64 &#37;1, ptr @&quot;jl_global#71842.jit&quot;, align 256
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture06/styles_of_paral
lelism.jmd:8 within &#96;h2&#96;
  br label &#37;L34

L34:                                              ; preds &#61; &#37;L18.preheader,
 &#37;top
  ret void
&#125;
</pre>


<p>It&#39;s still optimizing it&#33;</p>


<pre class='hljl'>
<span class='hljl-n'>non_const_len</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>10000</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>h3</span><span class='hljl-p'>()</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>acc_s</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>non_const_len</span><span class='hljl-t'>
  </span><span class='hljl-n'>len2</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>non_const_len</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-n'>len2</span><span class='hljl-t'>
      </span><span class='hljl-n'>acc_s</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>h3</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
4.939 ns &#40;0 allocations: 0 bytes&#41;
</pre>


<p>Note that what is shown here is a type-declaration. <code>a::T &#61; ...</code> forces <code>a</code> to be of type <code>T</code> throughout the whole function. By giving the compiler this information, I am able to use the non-constant global in a type-stable manner.</p>
<p>One last thing to note about multithreaded computations, and parallel computations, is that one cannot assume that the parallelized computation is computed in any given order. For example, the following will has a quasi-random ordering:</p>


<pre class='hljl'>
<span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>a2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>zeros</span><span class='hljl-p'>(</span><span class='hljl-nf'>nthreads</span><span class='hljl-p'>()</span><span class='hljl-oB'>*</span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>acc_lock2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Ref</span><span class='hljl-p'>{</span><span class='hljl-n'>Int64</span><span class='hljl-p'>}(</span><span class='hljl-ni'>0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>splock2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>SpinLock</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>f_order</span><span class='hljl-p'>()</span><span class='hljl-t'>
    </span><span class='hljl-nd'>@threads</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>a2</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nf'>lock</span><span class='hljl-p'>(</span><span class='hljl-n'>splock2</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-n'>acc_lock2</span><span class='hljl-p'>[]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
        </span><span class='hljl-n'>a2</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>acc_lock2</span><span class='hljl-p'>[]</span><span class='hljl-t'>
        </span><span class='hljl-nf'>unlock</span><span class='hljl-p'>(</span><span class='hljl-n'>splock2</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>f_order</span><span class='hljl-p'>()</span><span class='hljl-t'>
</span><span class='hljl-n'>a2</span>
</pre>


<pre class=output >
10-element Vector&#123;Float64&#125;:
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0
 10.0
</pre>


<p>Note that here we can see that Julia 1.5 is dividing up the work into groups of 10 for each thread, and then one thread dominates the computation at a time, but which thread dominates is random.</p>
<h3>The Dining Philosophers Problem</h3>
<p>A classic tale in parallel computing is the dining philosophers problem. In this case, there are N philosophers at a table who all want to eat at the same time, following all of the same rules. Each philosopher must alternatively think and then eat. They need both their left and right fork to start eating, but cannot start eating until they have both forks. The problem is how to setup a concurrent algorithm that will not cause any philosophers to starve.</p>
<p>The difficulty is a situation known as <em>deadlock</em>. For example, if each philosopher was told to grab the right fork when it&#39;s available, and then the left fork, and put down the fork after eating, then they will all grab the right fork and none will ever eat because they will all be waiting on the left fork. This is analogous to two blocked computations which are waiting on the other to finish. Thus, when using blocking structures, one needs to be careful about deadlock&#33;</p>
<h3>Two Programming Models: Loop-Level Parallelism and Task-Based Parallelism</h3>
<p>As described in the previous lecture, one can also use <code>Threads.@spawn</code> to do multithreading in Julia v1.3&#43;. The same factors all apply: how to do locks and Mutex etc. This is a case of a parallelism construct having two alternative <strong>programming models</strong>. <code>Threads.@spawn</code> represents task-based parallelism, while <code>Threads.@threads</code> represents Loop-Level Parallelism or a parallel iterator model. Loop-based parallelization models are very high level and, assuming every iteration is independent, almost requires no code change. Task-based parallelism is a more expressive parallelism model, but usually requires modifying the code to be explicitly written as a set of parallelizable tasks. Note that in the case of Julia, <code>Threads.@threads</code> is implemented using <code>Threads.@spawn</code>&#39;s model.</p>
<h3>Summary of Multithreading</h3>
<ul>
<li><p>Communication in multithreading is done on the heap. Locks and atomics allow for a form of safe message passing.</p>

<li><p>50ns-100ns of overhead. Suitable for 1μs calculations.</p>

<li><p>Be careful of ordering and heap-allocated values.</p>

</ul>
<h2>GPU Computing</h2>
<p>GPUs are not fast. In fact, the problem with GPUs is that each processor is slow. However, GPUs have a lot of cores... like thousands.</p>
<p><img src="https://miro.medium.com/max/832/0*xzPjWMqXC0NB6D69.jpg" alt="" /></p>
<p>An RTX2080, a standard &quot;gaming&quot; GPU &#40;not even the ones in the cluster&#41;, has 2944 cores. However, not only are GPUs slow, but they also need to be programmed in a style that is <em>SPMD</em>, which stands for Single Program Multiple Data. This means that every single thread must be running the same program but on different pieces of data. Exactly the same program. If you have</p>


<pre class='hljl'>
<span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-cs'># Do something</span><span class='hljl-t'>
</span><span class='hljl-k'>else</span><span class='hljl-t'>
  </span><span class='hljl-cs'># Do something else</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<p>where some of the data goes on one branch and other data goes on the other branch, every single thread will run both branches &#40;performing &quot;fake&quot; computations while on the other branch&#41;. This means that GPU tasks should be &quot;very parallel&quot; with as few conditionals as possible.</p>
<h3>GPU Memory</h3>
<p>GPUs themselves are shared memory devices, meaning they have a heap that is shared amongst all threads. However, GPUs are heavily in the NUMA camp, where different blocks of the GPU have much faster access to certain parts of the memory. Additionally, this heap is disconnected from the standard processor, so data must be passed to the GPU and data must be returned.</p>
<p>GPU memory size is relatively small compared to CPUs. Example: the RTX2080Ti has 8GB of RAM. Thus one needs to be doing computations that are memory compact &#40;such as matrix multiplications, which are O&#40;n^3&#41; making the computation time scale quicker than the memory cost&#41;.</p>
<h3>Note on GPU Hardware</h3>
<p>Standard GPU hardware &quot;for gaming&quot;, like RTX2070, is just as fast as higher end GPU hardware for Float32. Higher end hardware, like the Tesla, add more memory, memory safety, and Float64 support. However, these require being in a server since they have alternative cooling strategies, making them a higher end product.</p>
<h3>SPMD Kernel Generation GPU Computing Models</h3>
<p>The core programming models for GPU computing are SPMD kernel compilers, of which the most well-known is CUDA. CUDA is a C&#43;&#43;-like programming language which compiles to .ptx kernels, and GPU execution on NVIDIA GPUs is done by &quot;all steams&quot; of a GPU doing concurrent execution of the kernel &#40;generally, without going into more details, you can of &quot;all streams&quot; as just meaning &quot;all cores&quot;. More detailed views of GPU execution will come later&#41;.</p>
<p>.ptx CUDA kernels can be compiled from LLVM IR, and thus since Julia is a programming language which emits LLVM IR for all of its operations, native Julia programs are compatible with compilation to CUDA. The helper functions to enable this separate compilation path is CUDA.jl. Let&#39;s take a look at a basic CUDA.jl kernel generating example:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>CUDA</span><span class='hljl-t'>

</span><span class='hljl-n'>N</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-oB'>^</span><span class='hljl-ni'>20</span><span class='hljl-t'>
</span><span class='hljl-n'>x_d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>CUDA</span><span class='hljl-oB'>.</span><span class='hljl-nf'>fill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector stored on the GPU filled with 1.0 (Float32)</span><span class='hljl-t'>
</span><span class='hljl-n'>y_d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>CUDA</span><span class='hljl-oB'>.</span><span class='hljl-nf'>fill</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0f0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>  </span><span class='hljl-cs'># a vector stored on the GPU filled with 2.0</span><span class='hljl-t'>

</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>index</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>threadIdx</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>    </span><span class='hljl-cs'># this example only requires linear indexing, so just use `x`</span><span class='hljl-t'>
    </span><span class='hljl-n'>stride</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>blockDim</span><span class='hljl-p'>()</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-t'>
    </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>index</span><span class='hljl-oB'>:</span><span class='hljl-n'>stride</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-n'>nothing</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@cuda</span><span class='hljl-t'> </span><span class='hljl-n'>threads</span><span class='hljl-oB'>=</span><span class='hljl-ni'>256</span><span class='hljl-t'> </span><span class='hljl-nf'>gpu_add2!</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x_d</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>all</span><span class='hljl-p'>(</span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>y_d</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>.==</span><span class='hljl-t'> </span><span class='hljl-nfB'>3.0f0</span><span class='hljl-p'>)</span>
</pre>


<pre class=julia-error >
ERROR: The following 1 direct dependency failed to precompile:

CUDA 

Failed to precompile CUDA &#91;052768ef-5323-5732-b1bb-66c8b64840ba&#93; to &quot;/home/runner/.julia/compiled/v1.11/CUDA/jl_qg46fF&quot;.
ERROR: LoadError: InitError: type Nothing has no field major
Stacktrace:
  &#91;1&#93; getproperty
    @ ./Base.jl:49 &#91;inlined&#93;
  &#91;2&#93; __init__&#40;&#41;
    @ GPUCompiler ~/.julia/packages/GPUCompiler/kqxyC/src/GPUCompiler.jl:64
  &#91;3&#93; run_module_init&#40;mod::Module, i::Int64&#41;
    @ Base ./loading.jl:1378
  &#91;4&#93; register_restored_modules&#40;sv::Core.SimpleVector, pkg::Base.PkgId, path::String&#41;
    @ Base ./loading.jl:1366
  &#91;5&#93; _include_from_serialized&#40;pkg::Base.PkgId, path::String, ocachepath::String, depmods::Vector&#123;Any&#125;, ignore_native::Nothing; register::Bool&#41;
    @ Base ./loading.jl:1254
  &#91;6&#93; _include_from_serialized &#40;repeats 2 times&#41;
    @ ./loading.jl:1210 &#91;inlined&#93;
  &#91;7&#93; _require_search_from_serialized&#40;pkg::Base.PkgId, sourcepath::String, build_id::UInt128, stalecheck::Bool; reasons::Dict&#123;String, Int64&#125;, DEPOT_PATH::Vector&#123;String&#125;&#41;
    @ Base ./loading.jl:2057
  &#91;8&#93; _require&#40;pkg::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2527
  &#91;9&#93; __require_prelocked&#40;uuidkey::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2388
 &#91;10&#93; #invoke_in_world#3
    @ ./essentials.jl:1089 &#91;inlined&#93;
 &#91;11&#93; invoke_in_world
    @ ./essentials.jl:1086 &#91;inlined&#93;
 &#91;12&#93; _require_prelocked&#40;uuidkey::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2375
 &#91;13&#93; macro expansion
    @ ./loading.jl:2314 &#91;inlined&#93;
 &#91;14&#93; macro expansion
    @ ./lock.jl:273 &#91;inlined&#93;
 &#91;15&#93; __require&#40;into::Module, mod::Symbol&#41;
    @ Base ./loading.jl:2271
 &#91;16&#93; #invoke_in_world#3
    @ ./essentials.jl:1089 &#91;inlined&#93;
 &#91;17&#93; invoke_in_world
    @ ./essentials.jl:1086 &#91;inlined&#93;
 &#91;18&#93; require&#40;into::Module, mod::Symbol&#41;
    @ Base ./loading.jl:2260
 &#91;19&#93; include
    @ ./Base.jl:557 &#91;inlined&#93;
 &#91;20&#93; include_package_for_output&#40;pkg::Base.PkgId, input::String, depot_path::Vector&#123;String&#125;, dl_load_path::Vector&#123;String&#125;, load_path::Vector&#123;String&#125;, concrete_deps::Vector&#123;Pair&#123;Base.PkgId, UInt128&#125;&#125;, source::Nothing&#41;
    @ Base ./loading.jl:2881
 &#91;21&#93; top-level scope
    @ stdin:6
during initialization of module GPUCompiler
in expression starting at /home/runner/.julia/packages/CUDA/fGE8R/src/CUDA.jl:1
in expression starting at stdin:
</pre>


<p>The key to understanding the SPMD kernel approach is the <code>index &#61; threadIdx&#40;&#41;.x</code> and <code>stride &#61; blockDim&#40;&#41;.x</code> portions.</p>
<p><img src="https://juliagpu.gitlab.io/CUDA.jl/tutorials/intro1.png" alt="" /></p>
<p>The way kernels are expected to run in parallel is that they are given a specific block of the computation and are expected to write a kernel which only on that small block of the input. This kernel is then called on every separate thread on the GPU, making each CUDA core simultaneously compute each block. Thus as a user in such a SPMD programming model, you never specify the computation globally but instead simply specify how chunks should behave, giving the compiler the leeway to determine the optimal global execution.</p>
<h3>Array-Based GPU Computing Models</h3>
<p>The simplest version of GPU computing is the array-based programming model.</p>


<pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>);</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>CUDA</span><span class='hljl-t'>
</span><span class='hljl-cs'># Pass to the GPU</span><span class='hljl-t'>
</span><span class='hljl-n'>cuA</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cu</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>);</span><span class='hljl-t'> </span><span class='hljl-n'>cuB</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>cu</span><span class='hljl-p'>(</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>cuC</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>cuA</span><span class='hljl-oB'>*</span><span class='hljl-n'>cuB</span><span class='hljl-t'>
</span><span class='hljl-cs'># Pass to the CPU</span><span class='hljl-t'>
</span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>cuC</span><span class='hljl-p'>)</span>
</pre>


<pre class=julia-error >
ERROR: The following 1 direct dependency failed to precompile:

CUDA 

Failed to precompile CUDA &#91;052768ef-5323-5732-b1bb-66c8b64840ba&#93; to &quot;/home/runner/.julia/compiled/v1.11/CUDA/jl_0iZ6yF&quot;.
ERROR: LoadError: InitError: type Nothing has no field major
Stacktrace:
  &#91;1&#93; getproperty
    @ ./Base.jl:49 &#91;inlined&#93;
  &#91;2&#93; __init__&#40;&#41;
    @ GPUCompiler ~/.julia/packages/GPUCompiler/kqxyC/src/GPUCompiler.jl:64
  &#91;3&#93; run_module_init&#40;mod::Module, i::Int64&#41;
    @ Base ./loading.jl:1378
  &#91;4&#93; register_restored_modules&#40;sv::Core.SimpleVector, pkg::Base.PkgId, path::String&#41;
    @ Base ./loading.jl:1366
  &#91;5&#93; _include_from_serialized&#40;pkg::Base.PkgId, path::String, ocachepath::String, depmods::Vector&#123;Any&#125;, ignore_native::Nothing; register::Bool&#41;
    @ Base ./loading.jl:1254
  &#91;6&#93; _include_from_serialized &#40;repeats 2 times&#41;
    @ ./loading.jl:1210 &#91;inlined&#93;
  &#91;7&#93; _require_search_from_serialized&#40;pkg::Base.PkgId, sourcepath::String, build_id::UInt128, stalecheck::Bool; reasons::Dict&#123;String, Int64&#125;, DEPOT_PATH::Vector&#123;String&#125;&#41;
    @ Base ./loading.jl:2057
  &#91;8&#93; _require&#40;pkg::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2527
  &#91;9&#93; __require_prelocked&#40;uuidkey::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2388
 &#91;10&#93; #invoke_in_world#3
    @ ./essentials.jl:1089 &#91;inlined&#93;
 &#91;11&#93; invoke_in_world
    @ ./essentials.jl:1086 &#91;inlined&#93;
 &#91;12&#93; _require_prelocked&#40;uuidkey::Base.PkgId, env::String&#41;
    @ Base ./loading.jl:2375
 &#91;13&#93; macro expansion
    @ ./loading.jl:2314 &#91;inlined&#93;
 &#91;14&#93; macro expansion
    @ ./lock.jl:273 &#91;inlined&#93;
 &#91;15&#93; __require&#40;into::Module, mod::Symbol&#41;
    @ Base ./loading.jl:2271
 &#91;16&#93; #invoke_in_world#3
    @ ./essentials.jl:1089 &#91;inlined&#93;
 &#91;17&#93; invoke_in_world
    @ ./essentials.jl:1086 &#91;inlined&#93;
 &#91;18&#93; require&#40;into::Module, mod::Symbol&#41;
    @ Base ./loading.jl:2260
 &#91;19&#93; include
    @ ./Base.jl:557 &#91;inlined&#93;
 &#91;20&#93; include_package_for_output&#40;pkg::Base.PkgId, input::String, depot_path::Vector&#123;String&#125;, dl_load_path::Vector&#123;String&#125;, load_path::Vector&#123;String&#125;, concrete_deps::Vector&#123;Pair&#123;Base.PkgId, UInt128&#125;&#125;, source::Nothing&#41;
    @ Base ./loading.jl:2881
 &#91;21&#93; top-level scope
    @ stdin:6
during initialization of module GPUCompiler
in expression starting at /home/runner/.julia/packages/CUDA/fGE8R/src/CUDA.jl:1
in expression starting at stdin:
</pre>


<p>Let&#39;s see the transfer times:</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>cu</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>)</span>
</pre>


<pre class=julia-error >
ERROR: UndefVarError: &#96;cu&#96; not defined in &#96;Main&#96;
Suggestion: check for spelling errors or missing imports.
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>Array</span><span class='hljl-p'>(</span><span class='hljl-n'>cuC</span><span class='hljl-p'>)</span>
</pre>


<pre class=julia-error >
ERROR: UndefVarError: &#96;cuC&#96; not defined in &#96;Main&#96;
Suggestion: check for spelling errors or missing imports.
</pre>


<p>The cost transferring is about 20μs-50μs in each direction, meaning that one needs to be doing operations that cost at least 200μs for GPUs to break even. A good rule of thumb is that GPU computations should take at least a millisecond, or GPU memory should be re-used.</p>
<h3>Summary of GPUs</h3>
<ul>
<li><p>GPUs cores are slow</p>

<li><p>GPUs are SPMD</p>

<li><p>GPUs are generally used for linear algebra</p>

<li><p>Suitable for SPMD 1ms computations</p>

</ul>
<h2>Xeon Phi Accelerators and OpenCL</h2>
<p>Other architectures exist to keep in mind. Xeon Phis are a now-defunct accelerator that used X86 &#40;standard processors&#41; as the base, using hundreds of them. For example, the Knights Landing series had 256 core accelerator cards. These were all clocked down, meaning they were still slower than a standard CPU, but there were less restrictions on SPMD &#40;though SPMD-like computations were still preferred in order to heavily make use of SIMD&#41;. However, because machine learning essentially only needs linear algebra, and linear algebra is faster when restricting to SPMD-architectures, this failed. These devices can still be found on many high end clusters.</p>
<p>One alternative to CUDA is OpenCL which supports alternative architectures such as the Xeon Phi at the same time that it supports GPUs. However, one of the issues with OpenCL is that its BLAS implementation currently does not match the speed of CuBLAS, which makes NVIDIA-specific libraries still the king of machine learning and most scientific computing.</p>
<h2>TPU Computing</h2>
<p>TPUs are tensor processing units, which is Google&#39;s newest accelerator technology. They are essentially just &quot;tensor operation compilers&quot;, which in computer science speak is simply higher dimensional linear algebra. To do this, they internally utilize a BFloat16 type, which is a 16-bit floating point number with the same exponent size as a Float32 with an 8-bit significant. This means that computations are highly prone to <em>catastrophic cancellation</em>. This computational device only works because BFloat16 has primitive operations for FMA which allows 32-bit-like accuracy of multiply-add operations, and thus computations which are only dot products &#40;linear algebra&#41; end up okay. Thus this is simply a GPU-like device which has gone further to completely specialize in linear algebra.</p>
<h2>Multiprocessing &#40;Distributed Computing&#41;</h2>
<p>While multithreading computes with multiple threads, multiprocessing computes with multiple independent processes. Note that processes do not share any memory, not heap or data, and thus this mode of computing also allows for <em>distributed computations</em>, which is the case where processes may be on separate computing hardware. However, even if they are on the same hardware, the lack of a shared address space means that multiprocessing has to do <em>message passing</em>, i.e. send data from one process to the other.</p>
<h3>Distributed Tasks with Explicit Memory Handling: The Master-Worker Model</h3>
<p>Given the amount of control over data handling, there are many different models for distributed computing. The simplest, the one that Julia&#39;s Distributed Standard Library defaults to, is the <em>master-worker model</em>. The master-worker model has one process, deemed the master, which controls the worker processes.</p>
<p>Here we can start by adding some new worker processes:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Distributed</span><span class='hljl-t'>
</span><span class='hljl-nf'>addprocs</span><span class='hljl-p'>(</span><span class='hljl-ni'>4</span><span class='hljl-p'>)</span>
</pre>


<p>This adds 4 worker processes for the master to control. The simplest computations are those where the master process gives the worker process a job which returns the value afterwards. For example, a <code>pmap</code> operation or <code>@distributed</code> loop gives the worker a function to execute, along with the data, and the worker then computes and returns the result.</p>
<p>At a lower level, this is done by <code>Distributed.@spawn</code>ing jobs, or using a <code>remotecall</code> and <code>fetch</code>ing the result. <a href="https://github.com/ChrisRackauckas/ParallelDataTransfer.jl">ParallelDataTransfer.jl</a> gives an extended set of primitive message passing operations. For example, we can explicitly tell it to compute a function <code>f</code> on the remote process like:</p>


<pre class='hljl'>
<span class='hljl-nd'>@everywhere</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>.^</span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-cs'># Define this function on all processes</span><span class='hljl-t'>
</span><span class='hljl-n'>t</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>remotecall</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-nf'>randn</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>))</span>
</pre>


<p><code>remotecall</code> is a non-blocking operation that returns a <code>Future</code>. To access the data, one should use the blocking operation <code>fetch</code> to receive the data:</p>


<pre class='hljl'>
<span class='hljl-n'>xsq</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fetch</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span>
</pre>


<h3>Distributed Tasks with Implicit Memory Handling: Distributed Task-Based Parallelism</h3>
<p>Another popular programming model for distributed computation is task-based parallelism but where all of the memory handling is implicit. Since, unlike the shared memory parallelism case, data transfers are required for given processes to share heap allocated values, distributed task-based parallelism libraries tend to want a global view of the whole computation in order to build a sophisticated schedule that includes where certain data lives and when transfers will occur. Because of this, distributed task-based parallelism libraries tend to want the entire <strong>computational graph</strong> of the computation, to be able to restructure the graph as necessary with their own data transfer portions spliced into the compute. Examples of this kind of framework are:</p>
<ul>
<li><p>Tensorflow</p>

<li><p>dask &#40;&quot;distributed tasks&quot;&#41;</p>

<li><p>Dagger.jl</p>

</ul>
<p>Using these kinds of libraries requires building a directed acyclic graph &#40;DAG&#41;. For example, the following showcases how to use Dagger.jl to represent a bunch of summations:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Dagger</span><span class='hljl-t'>

</span><span class='hljl-nf'>add1</span><span class='hljl-p'>(</span><span class='hljl-n'>value</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>value</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
</span><span class='hljl-nf'>add2</span><span class='hljl-p'>(</span><span class='hljl-n'>value</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>value</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-nf'>combine</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>...</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>p</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>delayed</span><span class='hljl-p'>(</span><span class='hljl-n'>add1</span><span class='hljl-p'>)(</span><span class='hljl-ni'>4</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>q</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>delayed</span><span class='hljl-p'>(</span><span class='hljl-n'>add2</span><span class='hljl-p'>)(</span><span class='hljl-n'>p</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>r</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>delayed</span><span class='hljl-p'>(</span><span class='hljl-n'>add1</span><span class='hljl-p'>)(</span><span class='hljl-ni'>3</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>s</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>delayed</span><span class='hljl-p'>(</span><span class='hljl-n'>combine</span><span class='hljl-p'>)(</span><span class='hljl-n'>p</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>q</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>r</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nd'>@assert</span><span class='hljl-t'> </span><span class='hljl-nf'>collect</span><span class='hljl-p'>(</span><span class='hljl-n'>s</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>16</span>
</pre>


<p>Once the global computation is specified, commands like <code>collect</code> are used to instantiate the graph on given input data, which then run the computation in a &#40;potentially&#41; distributed manner, depending on internal scheduler heuristics.</p>
<h3>Distributed Array-Based Parallelism: SharedArrays, Elemental, and DArrays</h3>
<p>Because array operations are a standard way to compute in scientific computing, there are higher level primitives to help with message passing. A <code>SharedArray</code> is an array which acts like a shared memory device. This means that every change to a <code>SharedArray</code> causes message passing to keep them in sync, and thus this should be used with a performance caution. <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DistributedArrays.jl</a> is a parallel array type which has local blocks and can be used for writing higher level abstractions with explicit message passing. Because it is currently missing high-level parallel linear algebra, currently the recommended tool for distributed linear algebra is <a href="https://github.com/JuliaParallel/Elemental.jl">Elemental.jl</a>.</p>
<h3>MapReduce, Hadoop, and Spark: The Map-Reduce Model</h3>
<p>Many data-parallel operations work by mapping a function <code>f</code> onto each piece of data and then reducing it. For example, the sum of squares maps the function <code>x -&gt; x^2</code> onto each value, and then these values are reduced by performing a summation. MapReduce was a Google framework in the 2000&#39;s built around this as the parallel computing concept, and current data-handling frameworks, like Hadoop and Spark, continue this as the core distributed programming model.</p>
<p>In Julia, there exists the <code>mapreduce</code> function for performing serial mapreduce operations. It also work on GPUs. However, it does not auto-distribute. For distributed map-reduce programming, the <code>@distributed</code> for-loop macro can be used. For example, sum of squares of random numbers is:</p>


<pre class='hljl'>
<span class='hljl-nd'>@distributed</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>+</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>1000</span><span class='hljl-t'>
  </span><span class='hljl-nf'>rand</span><span class='hljl-p'>()</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<p>One can see that computing summary statistics is easily done in this framework which is why it was majorly adopted among &quot;big data&quot; communities.</p>
<p><code>@distributed</code> uses a static scheduler. The dynamic scheduling equivalent is <code>pmap</code>:</p>


<pre class='hljl'>
<span class='hljl-nf'>pmap</span><span class='hljl-p'>(</span><span class='hljl-n'>i</span><span class='hljl-oB'>-&gt;</span><span class='hljl-nf'>rand</span><span class='hljl-p'>()</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span>
</pre>


<p>which will dynamically allocate jobs to processes as they declare they have finished jobs. This thus has the same performance difference behavior as <code>Threads.@threads</code> vs <code>Threads.@spawn</code>.</p>
<h3>MPI: The Distributed SPMD Model</h3>
<p>The main way to do high-performance multiprocessing is <em>MPI</em>, which is an old distributed computing interface from the C/Fortran days. Julia has access to the MPI programming model through MPI.jl. The programming model for MPI is that every computer is running the same program, and synchronization is performed by blocking communication. For example, let&#39;s look at the following:</p>


<pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-t'>
</span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Init</span><span class='hljl-p'>()</span><span class='hljl-t'>

</span><span class='hljl-n'>comm</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-n'>COMM_WORLD</span><span class='hljl-t'>
</span><span class='hljl-n'>rank</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Comm_rank</span><span class='hljl-p'>(</span><span class='hljl-n'>comm</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>size</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Comm_size</span><span class='hljl-p'>(</span><span class='hljl-n'>comm</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>dst</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>mod</span><span class='hljl-p'>(</span><span class='hljl-n'>rank</span><span class='hljl-oB'>+</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>size</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>src</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>mod</span><span class='hljl-p'>(</span><span class='hljl-n'>rank</span><span class='hljl-oB'>-</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>size</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>N</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>

</span><span class='hljl-n'>send_mesg</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Array</span><span class='hljl-p'>{</span><span class='hljl-n'>Float64</span><span class='hljl-p'>}(</span><span class='hljl-n'>undef</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>recv_mesg</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Array</span><span class='hljl-p'>{</span><span class='hljl-n'>Float64</span><span class='hljl-p'>}(</span><span class='hljl-n'>undef</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>N</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>fill!</span><span class='hljl-p'>(</span><span class='hljl-n'>send_mesg</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nf'>Float64</span><span class='hljl-p'>(</span><span class='hljl-n'>rank</span><span class='hljl-p'>))</span><span class='hljl-t'>

</span><span class='hljl-n'>rreq</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Irecv!</span><span class='hljl-p'>(</span><span class='hljl-n'>recv_mesg</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>src</span><span class='hljl-p'>,</span><span class='hljl-t'>  </span><span class='hljl-n'>src</span><span class='hljl-oB'>+</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>comm</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>print</span><span class='hljl-p'>(</span><span class='hljl-s'>&quot;</span><span class='hljl-si'>$rank</span><span class='hljl-s'>: Sending   </span><span class='hljl-si'>$rank</span><span class='hljl-s'> -&gt; </span><span class='hljl-si'>$dst</span><span class='hljl-s'> = </span><span class='hljl-si'>$send_mesg</span><span class='hljl-se'>\n</span><span class='hljl-s'>&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>sreq</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Isend</span><span class='hljl-p'>(</span><span class='hljl-n'>send_mesg</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>dst</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>rank</span><span class='hljl-oB'>+</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>comm</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>stats</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Waitall!</span><span class='hljl-p'>([</span><span class='hljl-n'>rreq</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>sreq</span><span class='hljl-p'>])</span><span class='hljl-t'>

</span><span class='hljl-nf'>print</span><span class='hljl-p'>(</span><span class='hljl-s'>&quot;</span><span class='hljl-si'>$rank</span><span class='hljl-s'>: Received </span><span class='hljl-si'>$src</span><span class='hljl-s'> -&gt; </span><span class='hljl-si'>$rank</span><span class='hljl-s'> = </span><span class='hljl-si'>$recv_mesg</span><span class='hljl-se'>\n</span><span class='hljl-s'>&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>MPI</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Barrier</span><span class='hljl-p'>(</span><span class='hljl-n'>comm</span><span class='hljl-p'>)</span>
</pre>



<pre class='hljl'>
<span class='hljl-oB'>&gt;</span><span class='hljl-t'> </span><span class='hljl-n'>mpiexecjl</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-n'>n</span><span class='hljl-t'> </span><span class='hljl-ni'>3</span><span class='hljl-t'> </span><span class='hljl-n'>julia</span><span class='hljl-t'> </span><span class='hljl-n'>examples</span><span class='hljl-oB'>/</span><span class='hljl-ni'>04</span><span class='hljl-oB'>-</span><span class='hljl-n'>sendrecv</span><span class='hljl-oB'>.</span><span class='hljl-n'>jl</span><span class='hljl-t'>
</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Sending</span><span class='hljl-t'>   </span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Sending</span><span class='hljl-t'>   </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Received</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Sending</span><span class='hljl-t'>   </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Received</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-n'>Received</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>]</span>
</pre>


<p>Let&#39;s investigate this a little bit. Think about having two computers run this line-by-line side by side. They will both locally build arrays, and then call <code>MPI.Irecv&#33;</code>, which is an asynchronous non-blocking call to listen for a message from a given <code>rank</code> &#40;a rank is the ID for a given process&#41;. Then they call their <code>sreq &#61; MPI.Isend</code> function, which is an asynchronous non-blocking call to send a message <code>send_mesg</code> to the chosen <code>rank</code>. When the expected message is found, <code>MPI.Irecv&#33;</code> will then run on its green thread and finish, updating the <code>recv_mesg</code> with the information from the message. However, in order to make sure all of the messages are received, we have added in a blocking operation <code>MPI.Waitall&#33;&#40;&#91;rreq, sreq&#93;&#41;</code>, which will block all further execution on the given rank until both its <code>rreq</code> and <code>sreq</code> tasks are completed. After that is done, each given rank will have its updated data, and the script will continue on all ranks.</p>
<p>This model is thus very asynchronous and allows for many different computers to run one highly parallelized program, managing the data transmissions in a sparse way without a single computer in charge of managing the whole computation. However, it can be prone to deadlock, since errors in the program may for example require rank 1 to receive a message from rank 2 before continuing the program, but rank 2 won&#39;t continue to program until it receives a message from rank 1. For this reason, while MPI has been the most successful large-scale distributed computing model and almost all major high-performance computing &#40;HPC&#41; cluster competitions have been won by codes utilizing the MPI model, the MPI model is nowadays considered a last resort due to these safety issues.</p>
<h3>Summary of Multiprocessing</h3>
<ul>
<li><p>Cost is hardware dependent: only suitable for 1ms or higher depending on the connections through which the messages are being passed and the topology of the network.</p>

<li><p>The Master-worker programming model is Julia&#39;s <code>Distributed</code> model</p>

<li><p>The Map-reduce programming model is a common data-handling model</p>

<li><p>Array-based distributed computations are another abstraction, used in all forms of parallelism.</p>

<li><p>MPI is a SPMD model of distributed computing, where each process is completely independent and one just controls the memory handling.</p>

</ul>
<h2>The Bait-and-switch: Parallelism is about Programming Models</h2>
<p>While this looked like a lecture about parallel programming at the different levels and types of hardware, this wide overview showcases that the real underlying commonality within parallel program is in the <strong>parallel programming models</strong>, of which there are not too many. There are:</p>
<ul>
<li><p>Map-reduce parallelism models. <code>pmap</code>, MapReduce &#40;Hadoop/Spark&#41;</p>
<ul>
<li><p>Pros: Easy to use</p>

<li><p>Cons: Requires that your program is specifically only mapping functions <code>f</code> and reducing them. That said, many data science operations like <code>mean</code>, <code>variance</code>, <code>maximum</code>, etc. can be represented as map-reduce calls, which lead to the popularity of these approaches for &quot;big data&quot; operations.</p>

</ul>

<li><p>Array-based parallelism models. SIMD &#40;at the compiler level&#41;, <code>CuArray</code>, <code>DistributedArray</code>, <code>PyTorch.torch</code>, ...</p>
<ul>
<li><p>Pros: Easy to use, can have very fast library implementations for specific functions</p>

<li><p>Cons: Less control and restricted to specific functions implemented by the library. Parallelism matches the data structure, so it requires the user to be careful and know the best way to split the data.</p>

</ul>

<li><p>Loop-based parallelism models. <code>Threads.@threads</code>, <code>@distributed</code>, OpenMP, MATLAB&#39;s <code>parfor</code>, Chapel&#39;s iterator parallelism</p>
<ul>
<li><p>Pros: Easy to use, almost no code change can make existing loops parallelized</p>

<li><p>Cons: Refined operations, like locking and sharing data, can be awkward to write. Less control over fine details like scheduling, meaning less opportunities to optimize.</p>

</ul>

<li><p>Task-based parallelism models with implicit distributed data handling. <code>Threads.@spawn</code>, Dagger.jl, TensorFlow, dask</p>
<ul>
<li><p>Pros: Relatively high level, low risk of errors since parallelism is mostly handled for the user. User simply describes which functions to call in what order.</p>

<li><p>Cons: When used on distributed systems, implicit data handling is hard, meaning it&#39;s generally not as efficient if you don&#39;t optimize the code yourself or help the optimizer, and these require specific programming constructs for building the computational graph. Note this is only a downside for distributed data parallelism, whereas when applied to shared memory systems these aspects no longer require handling by the task scheduler.</p>

</ul>

<li><p>Task-based parallelism models with explicit data handling. <code>Distributed.@spawn</code></p>
<ul>
<li><p>Pros: Allows for control over what compute hardware will have specific pieces of data and allows for transferring data manually.</p>

<li><p>Cons: Requires transferring data manually. All computations are managed by a single process/computer/node and thus it can have some issues scaling to extreme &#40;1000&#43; node&#41; computing situations.</p>

</ul>

<li><p>SPMD kernel parallelism models. CUDA, MPI, KernelAbstractions.jl</p>
<ul>
<li><p>Pros: Reduces the problem for the user to only specify what happens in small chunks of the problem. Works on accelerator hardware like GPUs, TPUs, and beyond.</p>

<li><p>Cons: Only works for computations that be represented block-wise, and relies on the compiler to generate good code.</p>

</ul>

</ul>
<p>In this sense, the different parallel programming &quot;languages&quot; and features are much more similar than they are all different, falling into similar categories.</p>


<div class=footer >
  <p>
    Published from <a href=styles_of_parallelism.jmd >styles_of_parallelism.jmd</a>
    using <a href="http://github.com/JunoLab/Weave.jl">Weave.jl</a> v0.10.12 on 2024-12-16.
  </p>
</div>

<div class=back-to-top >
  <span><a href="#" title="Back to Top"><i class="fa fa-chevron-circle-up"></i></a></span>
</div>


</div>
        </div> 
    </div>